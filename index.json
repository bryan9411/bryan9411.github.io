[{"content":"再談 WEB3.0 前先來談談我們熟悉的 WEB2.0\nWeb2 以社群網路的概念為核心，例如我們熟知的 部落格、Instragram、維基百科等等。使用者可以使用搜尋功能、新增刪除內容，可以和其他網路使用者交流互動\n這時期網路使用者既是瀏覽者也是創作者，網路形成了一個雙向互動的平台\nWeb3 Web3 核心理念是讓資料透過去中心化的算法與協議儲存和溝通，網路應該開放而分散，而不是像現在將資訊集中在大型公司的資料庫中\n所以結合了區塊鏈技術的 web3 將會有以下特點：\n分散式運算：資料將不在存在固定位置，會以點對點方式將資料儲存 去中心化：使用者可以直接交流互動，而不需透過中間平台來傳遞訊系 去信任化：區塊鏈上的資訊無法偽造，使用者交易不用經過第三方平台或機構來保證 無權限化：不受國家地域限制，不用經過管理機構授權 ","permalink":"https://bryan9411.github.io/posts/blockchain-01/","summary":"再談 WEB3.0 前先來談談我們熟悉的 WEB2.0 Web2 以社群網路的概念為核心，例如我們熟知的 部落格、Instragram、維基百科等等。使用者可以使用搜尋功能、新增","title":"什麼是 Web3 ?"},{"content":"useEffect 異步函數，可以在函數組件中執行副作用操作，第二個參數為 dependences\n[] 為畫面載入時只執行一次，當有填寫參數進去時，當此參數值有變化就會重新 rerender 渲染畫面\n常用在資料獲取、訂閱或手動更改 React 組件的 DOM\nuseEffect(() =\u0026gt; { console.log(\u0026#39;useEffect 執行\u0026#39;) }, []) useLayoutEffect 同步函數，useLayoutEffect 與 useEffect 相似，但它會在所有的 DOM 變更之後同步調用副作用函數\n可以在瀏覽器畫出畫面之前讀取 DOM 並同步觸發 rerender\nuseLayoutEffect(() =\u0026gt; { console.log(\u0026#39;useLayoutEffect 執行\u0026#39;) }, []) 執行過程 import { useEffect, useLayoutEffect } from \u0026#39;react\u0026#39; const App = () =\u0026gt; { useEffect(() =\u0026gt; { console.log(\u0026#39;進入畫面第一次 useEffect 執行\u0026#39;) return () =\u0026gt; { console.log(\u0026#39;清理 useEffect \u0026#39;) } }, []) useLayoutEffect(() =\u0026gt; { console.log(\u0026#39;畫面畫完之後 useLayoutEffect 執行\u0026#39;) return () =\u0026gt; { console.log(\u0026#39;清理 useLayoutEffect \u0026#39;) } }, []) return \u0026lt;div\u0026gt;Hello World\u0026lt;/div\u0026gt; } export default App 上述執行順序結果為\n畫面畫完之後 useLayoutEffect 執行 進入畫面第一次 useEffect 執行 清理 useLayoutEffect 清理 useEffect 畫面畫完之後 useLayoutEffect 執行 進入畫面第一次 useEffect 執行 瀏覽器開始渲染畫面時會先執行 useLayoutEffect 的 func，在控制台中，會看到 \u0026ldquo;畫面畫完之後 useLayoutEffect 執行\u0026rdquo; 的 log 輸出，接著才會執行 useEffect並且去清理各自的副作用\n為什麼 useLayoutEffect 順序優先 useEffect ? useEffect 是在瀏覽器畫面渲染出來後才去做執行，而 useLayoutEffect 不同，是在瀏覽器還沒畫出畫面出來前就先去執行\n所以 useLayoutEffect 的回調函數會在 useEffect 的回調函數之前執行。同理，useLayoutEffect 的清理函數會在 useEffect 的清理函數之前執行\n","permalink":"https://bryan9411.github.io/posts/react-01/","summary":"useEffect 異步函數，可以在函數組件中執行副作用操作，第二個參數為 dependences [] 為畫面載入時只執行一次，當有填寫參數進去時，當此參數值有變化就會重新 rerender 渲染畫面 常","title":"useEffect 執行順序"},{"content":" 身為前端開發者一定聽過 npm 以及 yarn 這兩項套件管理工具，但其實還有一個叫 pnpm 的套件管理工具\n最近公司新專案在前端開發中，從 yarn 轉向使用 pnpm，這篇就來說一下體驗心得\n假如有一個叫做「Project A」的專案，裡面安裝了 React 和 lodash，使用 yarn 和 pnpm 來安裝這些依賴項\n使用 yarn 安裝 yarn 會將下載的 React 和 lodash 存儲在一個全局緩存目錄中，當使用 yarn 安裝時，會先檢查全局緩存中有沒有存在，如果存在就會直接使用這些緩存的檔案，而不是從網絡重新下載\n但是，即時使用了全局緩存，yarn 還是會將需安裝的依賴複製到每個專案的 node_modules 裡面\n也就是說，如果我們有另一個名為「Project B」的專案也一樣安裝相同版本的 React 和 lodash，yarn 會再次從全局緩存中複製一份 React 和 lodash 到 「Project B」\n使用 pnpm 安裝 pnpm 採用全局儲存方式，會將下載的檔案存儲在一個全局目錄中，當使用 pnpm 安裝時，會先檢查全局儲存目錄中有沒有存在，如果存在就會直接使用這些檔案，而不是從網絡重新下載\n與 yarn 不同的是 pnpm 不會將檔案複製到每個專案的 node_modules 裡面。相反，它會使用 link 方式直接指向全局存儲中的實際位置。這樣，每個專案的 node_modules 裡面就只包含指向全局存儲的連結，而不是整包檔案全部複製一次。\n兩者不同安裝方式差異 根據兩者安裝的方式，最關鍵區別在於硬碟空間的使用以及安裝的速度\n硬碟空間：\nyarn: 每個專案都會重新複製一份導致空間浪費 pnpm: 透過 linl 連結直接找到全局儲存的位置，無需重新複製 安裝速度：\nyarn: 要花時間將檔案複製到 node_modules pnpm: 無需將檔案重新複製，安裝上更加快速 ","permalink":"https://bryan9411.github.io/posts/node-01/","summary":"身為前端開發者一定聽過 npm 以及 yarn 這兩項套件管理工具，但其實還有一個叫 pnpm 的套件管理工具 最近公司新專案在前端開發中，從 yarn 轉向使用 pnpm，這篇就來","title":"為什麼 pnpm 速度快於 yarn ?"},{"content":"防抖（Debounce）用於限制連續觸發的事件的執行頻率，當一個事件被觸發後 debounce 會延遲一段時間，如果在這段時間內再次觸發該事件，則會重新計時。只有在這段延遲時間內沒有再次觸發該事件的話才會執行。\nDebounce 比較常用於以下情境：\n監聽表單欄位輸入，在停止輸入一段時間後才執行操作，以減少向後端發送請求的頻率 監聽視窗大小變化，在窗口大小變化停止一段時間後才重新計算 監聽滑鼠滾動事件，在滾動停止一段時間後才執行某些操作 這邊以第一個情境為例： const debounce = (func, delay) =\u0026gt; { let timerId return (...args) =\u0026gt; { clearTimeout(timerId) timerId = setTimeout(() =\u0026gt; { func.apply(this, args) }, delay) } } const search = debounce((keyword) =\u0026gt; { console.log(`搜索關鍵字：${keyword}`) }, 500) search(\u0026#39;JavaScript\u0026#39;) search(\u0026#39;React\u0026#39;) search(\u0026#39;CSS\u0026#39;) search(\u0026#39;Html\u0026#39;) // 執行後得出結果為 =\u0026gt; 搜索關鍵字：Html ","permalink":"https://bryan9411.github.io/posts/javascript-06/","summary":"防抖（Debounce）用於限制連續觸發的事件的執行頻率，當一個事件被觸發後 debounce 會延遲一段時間，如果在這段時間內再次觸發該事件，則會重新計時。","title":"Debounce(防抖)"},{"content":"什麼是 Closure(閉包) ? 當你在一個函數中定義了另一個函式，即使外部函數已經執行完畢，這個內部函數還是能夠訪問外部函數中的變數\nfunction outer () { var a = 10 function inner() { a++ console.log(a) } return inner } var result = outer() result() // 11 result() // 12 result() // 13 result() // 14 在 outer 函數內部，我們定義了一個內部函數 inner，它可以拿到外部函數 outer 中的變數 a 當我們呼叫 outer 函數時，它回傳了 inner 函數，並且將其賦值給變數 result 此時，result 實際上指向了 inner 函數，但它仍然能夠拿到並修改 outer 函式中的變數 a\n","permalink":"https://bryan9411.github.io/posts/javascript-05/","summary":"什麼是 Closure(閉包) ? 當你在一個函數中定義了另一個函式，即使外部函數已經執行完畢，這個內部函數還是能夠訪問外部函數中的變數 function outer () { var","title":"Closure(閉包)"},{"content":"什麼是 hoisting（提升）？ 在 vsCode 打上程式碼，如果沒有賦值會顯示錯誤如下\nconsole.log(a) // a is not defined 但是如果給它賦值，就會變成有 undefined 而非報錯\nconsole.log(a) // undefined var a = 10 上述兩者結合就像是這樣：\nvar a console.log(a) // undefined a = 10 這就是變數提升，當程式碼執行時，宣告的變數會被提升到其作用域的上方\n除了變數提升外 function 也可以提升\nfoo() // function 被提升，會輸出 Hello world! function foo() { console.log(\u0026#39;Hello, world!\u0026#39;) } 但有例外情況。假如是把變數賦值一個 function 的話是不能提升 function\nfoo() // foo is not a function var foo = function () { console.log(\u0026#39;Hello world!\u0026#39;) } 會這樣是因為提升的部份只有 foo 的變數，所以會是 undefined，而 undefined !== function 所以才會報錯\nhoisting 的順序 hoisting 只會發生在它的範圍內\nvar a = \u0026#39;全域變數\u0026#39; function foo() { console.log(a) // undefined var a = \u0026#39;範圍變數\u0026#39; } foo() ======== 上方程式碼等於下方 ======== var a = \u0026#39;全域變數\u0026#39; function foo() { var a console.log(a) //undefined a = \u0026#39;範圍變數\u0026#39; } foo() 從上述程式碼可以看到 hoisting 只會發生在 function 的範圍內\nfunction 有提升的優先權 function foo () { console.log(a) // [Function: a] function a () {} var a = \u0026#39;範圍變數\u0026#39; } foo() ============================================= function foo () { console.log(a) // [Function: a] var a = \u0026#39;範圍變數\u0026#39; function a () {} } foo() 可以看到不管變數 a 在 function a 前面或後面，優先提升的還是 function\n如果有重複的 function 呢？ function foo () { console.log(a) // [Function: a] a() // second function function a () { console.log(\u0026#39;first function\u0026#39;) } var a = \u0026#39;範圍變數\u0026#39; function a () { console.log(\u0026#39;second function\u0026#39;) } } foo() 後面的 function 會蓋掉前面的 function\n當傳入的變數跟內部的變數一樣時 function foo (a) { var a console.log(a) a = 456 } foo(123) // 123 當函數 foo 執行時，它的參數 a 被賦值為 123，接著，由於變數提升，函式內部的 var a 被提升到了函數的頂部\n但這個宣告對程式碼的執行沒有影響，因為參數 a 已經存在且已經賦值，所以會印出函數的參數 a 的值\n變數跟 function 優先權比較 function foo(a) { console.log(a) var a = 10 function a() {} } foo(123) // [Function a] 從上面程式碼可以看到 function 會蓋過變數的提升，所以 function 優先權大於變數\n","permalink":"https://bryan9411.github.io/posts/javascript-04/","summary":"什麼是 hoisting（提升）？ 在 vsCode 打上程式碼，如果沒有賦值會顯示錯誤如下 console.log(a) // a is not defined 但是如果給它賦值，就會變成有 undefined 而非報錯 console.log(a) // undefined var a = 10 上","title":"hoisting（提升)"},{"content":"一般的重新賦值，只要修改值就會變更\nvar a = 10 console.log(a) // 10 a = 20 console.log(a) // 20 但是物件狀態就不一樣了\nvar objA = { number: 10 } var objB = objA console.log(objA, objB) // { number: 10 } { number: 10 } objA.number = 20 console.log(objA, objB) // { number: 20 } { number: 20 } 發現 objA 物件修改值，兩邊就會改值\n會這樣的原因跟底層有關係，物件是以一種記憶體形式方式儲存，再把變數指向這個記憶體位置。因為兩個儲存的記憶體位置是一樣的，所以一改之後就會其他的部份也改了\n/** * objA 記憶體位置 0x01, objB 記憶體位置 0x02 */ var objA = { number: 10 } var objB = objA // 將 objB 指向了 objA 的記憶體位置，而不是在創建一個新的物件 console.log(objB === objA) // true 因為記憶體儲存位置一樣 接著看下面這例子\nvar arr = [1, 2, 3] var arr2 = [1, 2, 3] console.log(arr[0] === arr2[0]) // true console.log(arr === arr2) // false arr 與 arr2 是兩個不同的陣列物件，它們位於記憶體中不同的位置\narr: 0x01\narr2: 0x02\n因為它們指向不同的記憶體位置，所以 console.log(arr === arr2) 輸出為 false\n但是當比較的 arr[0] 和 arr2[0]，實際上比較的是這兩個陣列中的第一個元素，而不是記憶體位置， 所以 console.log(arr[0] === arr2[0] 輸出為 true\n","permalink":"https://bryan9411.github.io/posts/javascript-03/","summary":"一般的重新賦值，只要修改值就會變更 var a = 10 console.log(a) // 10 a = 20 console.log(a) // 20 但是物件狀態就不一樣了 var objA = { number: 10 } var objB = objA console.log(objA, objB) // { number: 10 } { number: 10 } objA.number = 20 console.log(objA, objB) // {","title":"JS 變數底層運作"},{"content":"","permalink":"https://bryan9411.github.io/archives/archives/","summary":"","title":"Archives"},{"content":"再介紹 GraphQL 之前要先介紹一下過去我們常用串 api 的方式 RESTful API。\nRESTful API RESTful API 它是一種架構風格，使用標準的 HTTP 方法 ，例如：GET、POST、PUT、DELETE 方法來做串接。優點在於簡單易懂好學且容易實現，緩存性也比較好，可以有效提升效能。\nRESTful API 還有一種特性是無狀態性（Statelessness），這表示每一個請求都是獨立且不依賴於之前的請求。這使得伺服器不需要保存客戶端的狀態，有助於提高伺服器的擴展性。\n反之其缺點需要多個請求來獲取完整資料，有可能造成過度取得資料問題產生。\n例如:\n假設有一個部落格，我們想獲取文章列表以及每篇文章的作者資訊：\n獲取所有文章列表: 使用 GET 方法去獲取 /articles 底下的所有文章 獲取每篇文章的作者資訊: 使用 GET 方法去獲取 /users/{userId} 作者資訊 GraphQL GraphQL 是一由 Facebook 開發的查詢語言，它可以允許 客戶端(client) 指定其所需的數據結構，並且僅返回這些構。 這樣的好處在於客戶端(client)可以根據自己的需求來精確地獲取資料，也可避免過度取得資料減少請求次數。 相較於 RESTful API ，GraphQL 學習成本較高相對較複雜，且在某些場景下可能存在過度複雜的查詢。\n雖然 GraphQL 學習成本高，但具有更大的靈活性和更精確的獲取資料。適用於對於不同資料需求的客戶端，從而減少過度取得資料的問題。\n在 GraphQL 中，要從伺服器獲取資料使用 query 而其他編修則是使用 mutation\n例如:\n同樣使用部落格來當作舉例，可以使用 query 來獲取文章列表以及作者資訊：\nquery { articles { title content user { name email } } } 在這個例子中，articles 查詢的每篇文章都有一個 user 屬性，該屬性包含作者資訊。 這與 RESTful API 中的 /articles 與 /users/{userId} 的結構相對應。\n當你要編修資料時可以使用 mutation，例如創建新文章，可能需要標題(title)、內容(content)、作者(userId):\nmutation { createArticle(input: { title: \u0026#39;哈利波特\u0026#39; content: \u0026#39;哈利波特與佛地魔\u0026#39; userId: \u0026#39;{userId}\u0026#39; }) { title content user { name email } } } 在這個例子中，input 參數接收一個物件，其中裡面包含了標題、內容以及作者的 ID。\ninput: { title: \u0026#39;哈利波特\u0026#39; content: \u0026#39;哈利波特與佛地魔\u0026#39; userId: \u0026#39;{userId}\u0026#39; } 在回傳結果中， GraphQL 可以讓我們指定希望回傳的資料，在這例子中我希望回傳給我標題、內容以及作者的名字和郵件\n{ title content user { name email } } 兩段結合也就是說新增一篇標題為 \u0026lsquo;哈利波特\u0026rsquo;，內容為 \u0026lsquo;哈利波特與佛地魔\u0026rsquo; 的文章，同時將這篇文章新增到該作者底下。最後，回傳文章的標題、內容，以及作者的名字和郵件。\n總結 最後用表格整理一下兩種不同 api 方式的差異性\nRESTful API GraphQL 資料的取得方式 回傳整包資料，可能包含過多或不足的資訊 可以指定需要回傳的資料，精確獲取所需資訊 請求次數 可能需要多次請求以獲取完整資訊 一次請求即可獲取多個資料 ","permalink":"https://bryan9411.github.io/posts/graphql-01/","summary":"再介紹 GraphQL 之前要先介紹一下過去我們常用串 api 的方式 RESTful API。 RESTful API RESTful API 它是一種架構風格，使用標準的 HTTP 方法 ，例如：GET、POST、PUT、DELE","title":"GraphQL 與 RESTful API 差異"},{"content":"什麼是 Dockerfile？ Dockerfile 包含了一系列的指令和配置，用於自動化生成 Docker Image Dockerfile，可以定義容器的環境和配置，可以讓 Image 的建立和部署變得更加容易\nDockerfile 指令 From 指定要安裝的 Image\nFrom alpine:lastest ENTRYPOINT 如果要在背景執行需要一個事件讓 docker 不停地去執行 例如不停地查看 dev 資料夾底下的 null log docker run -d test01 tail -f /dev/null\n現在想要將這 test01 image 給別人使用，但是不想讓別人知道一定要打上這段 tail -f /dev/null 指令才可以背景執行的話，可以透過 ENTRYPOINT這語法來解決\nENTRYPOINT 代表這個 image 會第一個執行的命令\nENTRYPOINT [\u0026#34;tail\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;/dev/null\u0026#34;] RUN 在 Image build 時才會執行命令\n## 在 image build 時，echo 出文字並且列出根目錄下的檔案 RUN echo \u0026#34;I am in the image process\u0026#34; RUN ls -l / ENV ENV 設置環境變數變數\nENV DB_HOST \u0026#34;localhost\u0026#34; RUN echo ${DB_HOST} RUN ls -l / WORKDIR 指定預設目錄\n## 這樣預設入口點會是在 dev 資料夾內，好處是無需再使用指令 RUN 進入 dev 資料夾才印出 echo message ## 可以使整個 dockerfile 更為簡潔 WORKDIR /dev RUN echo ${processMessage} ARG 跟 ENV 有點類似都是建立變數，唯一不同在於 ENV 可在 image build 時執行，而 ARG 無法\nARG name=bryan 建立簡易的 Dockerfile 綜合上面所說的指令來製作一個簡單的 Dockerfile\n## 指定要安裝的 Image From alpine ## ENV 環境變數 ENV DB_HOST=\u0026#34;localhost\u0026#34; ## 指定預設目錄 WORKDIR /dev ## 在 image build 時才會執行 RUN echo ${DB_HOST} RUN ls -l / ## 這個 image 會第一個執行的命令 ENTRYPOINT [\u0026#34;tail\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;/dev/null\u0026#34;] docker build -t test01 . 建立一個新的 image\n[+] Building 0.2s (8/8) FINISHED =\u0026gt; [internal] load build definition from Dockerfile 0.0s =\u0026gt; =\u0026gt; transferring dockerfile: 318B 0.0s =\u0026gt; [internal] load .dockerignore 0.0s =\u0026gt; =\u0026gt; transferring context: 2B 0.0s =\u0026gt; [internal] load metadata for docker.io/library/alpine:latest 0.0s =\u0026gt; [1/4] FROM docker.io/library/alpine 0.0s =\u0026gt; CACHED [2/4] WORKDIR /dev 0.0s =\u0026gt; CACHED [3/4] RUN echo localhost 0.0s =\u0026gt; [4/4] RUN ls -l / 0.1s =\u0026gt; exporting to image 0.0s =\u0026gt; =\u0026gt; exporting layers 0.0s =\u0026gt; =\u0026gt; writing image sha256:478cf4f35add82783b8afc107061807439b9d391d1615e4b999089ae79ba7183 0.0s =\u0026gt; =\u0026gt; naming to docker.io/library/test01 docker images 查看 images\nREPOSITORY TAG IMAGE ID CREATED SIZE test01 latest 478cf4f35add About a minute ago 7.73MB ","permalink":"https://bryan9411.github.io/posts/docker-04/","summary":"什麼是 Dockerfile？ Dockerfile 包含了一系列的指令和配置，用於自動化生成 Docker Image Dockerfile，可以定義容器的環境和配置，可以讓 Image 的建立和部","title":"Dockerfile"},{"content":"docker run 建立並執行一個新的容器\n後面可帶參數：\n-d: 在背景執行 -e: 設置環境變數 -p: 將 port 映射 (host port:container port) -it: 交互式模式 \u0026ndash;name: 命名容器名稱 \u0026ndash;restart: 重新啟動容器 docker ps 顯示目前正在執行的容器\n後面可帶參數：\n-a: 顯示所有容器 -q: 只顯示容器 id docker rm 刪除容器\n後面可帶參數：\n-f: 強制刪除容器 docker exec 進入容器裡面執行指令\n後面可帶參數：\n-d: 在背景執行 -u: 指定使用者 -e: 設定環境變數 -w: 指定工作目錄 -it: 交互模式 以 Docker Hub 提供的 alpine image 為例 先將 image 下載下來\ndocker pull alpine 建立一個新的 container ，去執行這個 image\ndocker run alpine 這時去查看容器狀態會發現沒有任何容器正在被執行，這是因為當容器運行的主進程跑完時，容器會自己退出結束\n如果想要在背景一直持續運作的話\ndocker run -d --name test01 alpine tail -f /dev/null 意思就是建立並執行一個容器，將該容器名稱命名為 \u0026ldquo;test01\u0026rdquo;\n使用背景模式持續執行 tail -f /dev/null 這個命令，讓 docker 持續去查看這文件\n建立好容器後，再檢查一次容器狀態\n如果出現下圖代表已成功建立容器，且背景持續執行\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8e1989d494fe alpine \u0026#34;tail -f /dev/null\u0026#34; 8 seconds ago Up 7 seconds test01 如何將 本機 port 映射到容器的 port？ nginx 是一個 web server，這次以 nginx image 為例，將本機 port 映射到 container 的 port\n先下載 nginx image\ndocker pull nginx 將本地主機 port 映射到 container port\ndocker run -d -p 8081:80 --name test02 nginx 建立好後檢查一下容器狀態，會發現 PORTS 欄位顯示本機 8081 port 已經被映射到容器的 80 port\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 00e08721216d nginx \u0026#34;/docker-entrypoint.…\u0026#34; 4 seconds ago Up 3 seconds 0.0.0.0:8081-\u0026gt;80/tcp test02 打開瀏覽器輸入 http://127.0.0.1:8081/ 可以成功看到 nginx server 歡迎頁面 ","permalink":"https://bryan9411.github.io/posts/docker-03/","summary":"docker run 建立並執行一個新的容器 後面可帶參數： -d: 在背景執行 -e: 設置環境變數 -p: 將 port 映射 (host port:container port) -it: 交互式模式 \u0026ndash;name: 命名容器名稱 \u0026ndash;restart: 重新啟動容器 docker ps 顯示目前正在執","title":"Docker container"},{"content":"Docker Hub Docker hub是 Docker 官方維護了一個公共倉庫，裡面放置大多數的 image 檔案，像是如果需要 ubuntu 或 Linux 環境，都可以在這網站下載到相關 image\n下載 Image 啟動 docker 在 Docker hub 網站註冊登入 搜尋 hello-world 這個 image 映像檔 指令 docker pull hello-world 把該 image 映像檔下載下來 查看本地 Image 啟動 docker 輸入 docker images 會顯示本機已有的映像檔\nREPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest ee301c921b8a 11 months ago 9.14kB 在上述這段訊息中，可以得到幾個資訊：\n來自於哪個倉庫: hello-world 版本資訊：latest 最新版 IMAGE ID 建立時間 該 image 大小 啟動 Image image 下載完後，要起一個 docker container ，然後把 hello-world 這個 image 放進 container 裡面\ndocker container run hello-world 如果終端機出現以下訊息，就說明已經成功將這 image 跑起來\nHello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \u0026#34;hello-world\u0026#34; image from the Docker Hub. (arm64v8) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ 刪除 Image 只要知道 image 名稱，就可以透過指令做刪除\ndocker rmi hello-world 另外，刪除 image 時有可能會遇到以下這錯誤\nError response from daemon: conflict: unable to remove repository reference \u0026#34;hello-world\u0026#34; (must force) - container 68df6174ffdb is using its referenced image ee301c921b8a 這是因為這個 image 正在被 reference by 68df6174ffdb 這個 conatainer id\n所以要先把這個 container 砍掉，沒了 container 才可以刪除 image\n// 先刪除 container docker rm 68df6174ffdb // 再刪除 image docker rmi hello-world 如果不想管有沒有被 reference 的話 如果不想管有沒有被 referenced 的話，可以使用 force 方式強制刪除\ndocker rmi -f hello-world ","permalink":"https://bryan9411.github.io/posts/docker-02/","summary":"Docker Hub Docker hub是 Docker 官方維護了一個公共倉庫，裡面放置大多數的 image 檔案，像是如果需要 ubuntu 或 Linux 環境，都可以在這網站下載到相關 image 下載 Image 啟動 docker 在 Docker hub 網站註冊","title":"Docker Image"},{"content":" 什麼是 Docker ? Docker 是一個開源的容器化平台，由 Dockerfile 、 Docker Image 、 Docker Container 三者組成\n可將應用程式及其相關環境打包成一個獨立的容器(Container)，確保應用程式在不同的環境中能夠快速運行，而不受環境變化的影響。\n安裝 Docker\n官方文件\nDocker 與虛擬機(Virtual Machine)區別 Docker 主要優勢在於部署快速、環境一致性、效能高、容易管理，可以快速地部署和啟動容器，並且容器之間可以獨立運行，互不影響。\n另外可以確保在不同的開發、測試環境中程式的一致性，避免因開發環境不同而引起問題。\n加上 Docker 是屬於輕量級應用，由多個容器去共享主機資源，效能比較高，而虛擬機是有自己獨立的虛擬化環境，相對來說比較效能較低。\nDocker 虛擬機 (Virtual Machine) 部署與啟動速度 快速，低資源消耗 較長的啟動時間，較高資源消耗 環境一致性 是 擁有自己獨立的虛擬化環境 虛擬化環境 多個容器共享主機資源 容器之間可以獨立運行，效能高 獨立的虛擬化環境，效能較差 程式一致性 可確保不同環境中程式的一致性 需要特別注意環境配置的一致性 Dockerfile 包含一系列指令，用於建立 Imgae\nFROM：指定 image RUN：執行指令 COPY：將本地文件複製到 image 裡面 WORKDIR：設定工作目錄 CMD：定義容器啟動時運行的指令 Docker Image 包含了運行容器所需的所有內容：程式碼、運行環境、環境變數和配置\u0026hellip;等，這些設定都是從 Dockerfile 取得 透過 docker build 根據 Dockerfile 來建立新的 image\nDocker Container 一個具有自己環境變數的容器，可以在容器內部進行開發測試和部署 \u0026hellip; 等等\n三者關係與流程 使用 Dockerfile 建立 image 設定 通過 docker build 命令根據 Dockerfile 創建新的 image 使用 docker run 命令根據 image 建立一個新的容器 ","permalink":"https://bryan9411.github.io/posts/docker-01/","summary":"什麼是 Docker ? Docker 是一個開源的容器化平台，由 Dockerfile 、 Docker Image 、 Docker Container 三者組成 可將應用程式及其相關環境打包成一個獨立的容器(Container)，確保應用程式","title":"Docker 介紹"},{"content":"假如從後端拿到的 member 資料為以下格式：\nmember = { name: \u0026#39;Bryan\u0026#39;, age: 30, gender: \u0026#39;male\u0026#39; } 要拿到該物件底下所有 item 的 key // 返回一個包含物件所有屬性名稱的陣列 const keys = Object.keys(member) console.log(keys) // [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;] 要拿到該物件底下所有 item 的 value // 返回一個包含物件所有屬性值的陣列 const values = Object.values(member) console.log(values) // 輸出：[\u0026#39;John\u0026#39;, 25, \u0026#39;male\u0026#39;] 要拿到該物件底下所有 item 對應的 key 跟 value // 返回一個包含物件所有屬性名稱和屬性值的陣列 const entries = Object.entries(member) console.log(entries) // 輸出： // [ // [\u0026#39;name\u0026#39;, \u0026#39;John\u0026#39;], // [\u0026#39;age\u0026#39;, 25], // [\u0026#39;gender\u0026#39;, \u0026#39;male\u0026#39;] // ] 將另一個物件資料複製並加入到當前物件 const newMember = { email: \u0026#39;test@gmail.com\u0026#39; } Object.assign(newMember, member) console.log(\u0026#39;newMember\u0026#39;, newMember) // 輸出： // { // name: \u0026#39;John\u0026#39;, // age: 25, // gender: \u0026#39;male\u0026#39;, // email: \u0026#39;test@gmail.com\u0026#39; // } 檢查物件是否具有指定的屬性 console.log(member.hasOwnProperty(\u0026#39;name\u0026#39;)) // true console.log(member.hasOwnProperty(\u0026#39;height\u0026#39;)) // false ","permalink":"https://bryan9411.github.io/posts/javascript-02/","summary":"假如從後端拿到的 member 資料為以下格式： member = { name: \u0026#39;Bryan\u0026#39;, age: 30, gender: \u0026#39;male\u0026#39; } 要拿到該物件底下所有 item 的 key // 返回一個包含物件所有屬性名稱的陣列 const keys = Object.keys(member) console.log(keys) // [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;] 要拿到","title":"JS 物件函數"},{"content":"介紹工作上常使用到的字串函數方法\ntrim 移除字串的開頭和結尾的空白字元 const str = \u0026#39; Hello, World! \u0026#39; const trimStr = str.trim() console.log(trimStr) // \u0026#39;Hello, World!\u0026#39; indexOf 找出指定字串出現位置的 index const str = \u0026#39;Hello, World!\u0026#39; const index = str.indexOf(\u0026#39;World\u0026#39;) console.log(index) // 7 lastIndexOf 找出指定字串最後一個出現位置的 index const str = \u0026#39;Hello, World!\u0026#39; const lastIndex = str.lastIndexOf(\u0026#39;o\u0026#39;) console.log(lastIndex) // 8 charAt 取得指定位置的 index const str = \u0026#39;Hello, World!\u0026#39; const char = str.charAt(4) console.log(char) // \u0026#39;o\u0026#39; slice 從字串中擷取一個子字串 const str = \u0026#39;Hello, World!\u0026#39; const slicedStr = str.slice(7, 12) console.log(slicedStr) // \u0026#39;World\u0026#39; concat 將多個字串連接在一起 const str1 = \u0026#39;Hello\u0026#39; const str2 = \u0026#39;World\u0026#39; const concatenatedStr = str1.concat(\u0026#39;, \u0026#39;, str2, \u0026#39;!\u0026#39;) console.log(concatenatedStr) // \u0026#39;Hello, World!\u0026#39; replace 將指定字串替換 const str = \u0026#39;Hello, World!\u0026#39; const replacedStr = str.replace(\u0026#39;World\u0026#39;, \u0026#39;Everyone\u0026#39;) console.log(replacedStr) // \u0026#39;Hello, Everyone!\u0026#39; split 將字串分割成字串陣列 const str = \u0026#39;Hello, World!\u0026#39; const splittedStr = str.split(\u0026#39;, \u0026#39;) console.log(splittedStr) // [\u0026#39;Hello\u0026#39;, \u0026#39;World!\u0026#39;] join 將字串陣列中的所有元素連接成一個字串 const arr = [\u0026#39;Hello\u0026#39;, \u0026#39;World!\u0026#39;] const joinedStr = arr.join(\u0026#39;, \u0026#39;) console.log(joinedStr) // \u0026#39;Hello, World!\u0026#39; ","permalink":"https://bryan9411.github.io/posts/javascript-01/","summary":"介紹工作上常使用到的字串函數方法 trim 移除字串的開頭和結尾的空白字元 const str = \u0026#39; Hello, World! \u0026#39; const trimStr = str.trim() console.log(trimStr) // \u0026#39;Hello, World!\u0026#39; indexOf 找出指定字串出現位置的 index const str = \u0026#39;Hello, World!\u0026#39; const index = str.indexOf(\u0026#39;World\u0026#39;) console.log(index)","title":"JS 字串函數"},{"content":" fetch vs pull 指令 說明 fetch 從遠端下載最新的資料，但不合併到本地分支。 pull 從遠端下載最新的資料並合併到本地分支，其實就是執行 git fetch 和 git merge 兩個指令的組合。 ","permalink":"https://bryan9411.github.io/posts/git-03/","summary":"fetch vs pull 指令 說明 fetch 從遠端下載最新的資料，但不合併到本地分支。 pull 從遠端下載最新的資料並合併到本地分支，其實就是執行 git fetch 和 git merge 兩個指令的組合。","title":"Fetch vs Pull "},{"content":" 再 Git: 基本指令 介紹到一些基本 git 指令，但還有更多實用的指令 👇\n修改提交(amend) git commit --amend 如果這次修改只是增加註解或者刪除多餘 log 之類的，並沒有其他功能，這樣的話用 --amend 可以直接修改目前 commit 紀錄，避免多一個新 commit\n撤銷提交(reset) reset 有三種模式可選，分別是 --soft、--mixed 和 --hard 可以用來撤銷提交、重置分支、取消暫存等操作\n模式 說明 \u0026ndash;soft 撤銷最近的提交，但保留修改的文件，通常用於將提交合併到一個新的提交 \u0026ndash;mixed 取消暫存文件 \u0026ndash;hard 刪除提交，一但刪除就救不回來了，使用時需小心 撤銷最近的提交，保留修改的文件：\ngit reset --soft HEAD~1 使用情境：你最近提交了一個錯誤的修改，但想要將這些修改合併到一個新的提交中\n指定檔案取消暫存：\ngit reset --mixed HEAD hello.ts 使用情境：你對某個檔案進行了修改並暫存，但後來決定不想提交這些修改\n刪除最近的提交及修改的文件：\ngit reset --hard HEAD~1 使用情境：你提交了一個錯誤的修改，現在想要完全刪除這個提交及修改的文件\n如果不清楚 HEAD~1 的意思，還有個更簡單做法：\n使用 git log 查看要回到的提交的 SHA 值。 複製該 SHA 值。 執行 git reset \u0026lt;SHA\u0026gt;，回到指定的提交位置並保留修改的文件。 重置基底(rebase) 指令 說明 rebase 從遠端拉取最新資料，並將本地未提交的修改與拉取的最新資料合併，生成一個新的提交紀錄 --rebase 從遠端拉取最新資料，但直接將本地未提交的修改更新到最新的程式碼，避免產生不必要的合併提交紀錄 假設你在本地也有一些未提交的修改，並想要從遠端的 origin/dev 分支拉取最新的資料 👇\nrebase： 如果拉取的最新的資料想要合併到你的本地分支且希望產生一個 commit 紀錄\ngit pull rebase origin dev 這將從遠端的 origin/dev 分支拉取最新的資料，並將你的本地未提交的修改與這些最新的資料進行合併。最後，產生一個 commit 紀錄\n\u0026ndash;rebase： 反之，如果不想產生額外的 commit 紀錄的話\ngit pull --rebase origin dev 這將從遠端的 origin/dev 分支拉取最新的資料，並直接將你的本地未提交的修改更新到這些最新的程式碼上。且不會產生 commit 紀錄\n","permalink":"https://bryan9411.github.io/posts/git-02/","summary":"再 Git: 基本指令 介紹到一些基本 git 指令，但還有更多實用的指令 👇 修改提交(amend) git commit --amend 如果這次修改只是增加註解或者刪除多餘 log 之類的，並沒有其他","title":"如何修改提交與重置"},{"content":" Git 它是一個版本控制系統，可以幫助你追蹤程式碼變化、管理版本、合作開發，是團隊協作中不可或缺的工具之一。\n以下是一些基本的 git 指令與使用情境 👇\ninit 當開始一個新專案時，首先需要初始化一個新的 git repository\n這個指令會在當前目錄下創建一個新的 git repository，並且開始追蹤你的文件檔案\ngit init clone 當需要從遠端(通常是 gitlab or github)拉下專案到你的本機開發\n上述是以 github 為範例，會從你的遠端位置拉下指定的專案到你本機環境\ngit clone https://github.com/你的使用者名稱/要拉下的專案名稱.git status 查看工作目錄和暫存區的狀態，看哪些文件已修改、哪些文件準備提交\ngit status log 查看提交記錄\ngit log add 將工作目錄中特定檔案的修改添加到暫存區\n\u0026lt;!--- 這只會將 index.html 這檔案的修改添加到暫存區 --\u0026gt; git add index.html 把全部修改得檔案添加到暫存區 👇\n\u0026lt;!--- add 後面需多加個 . 代表把所有檔案包含剛新建的檔案或資料夾都給添加到暫存區 --\u0026gt; git add . 只有被 git 追蹤的檔案添加到暫存區 👇\n\u0026lt;!--- -u 只會將有被加入 git 追蹤的檔案修改添加到暫存區 新建的檔案或資料夾都不會添加到暫存區 --\u0026gt; git add -u commit 將暫存區的修改提交到本地，當 commit 完後可以透過 git log 查看整個提交記錄\ngit commit -m \u0026#39;first commit\u0026#39; branch 建立一個新分支\n\u0026lt;!--- 建立名為 dev 分支--\u0026gt; git branch dev checkout 從 A 分支切換到 B 分支\n\u0026lt;!--- 假設目前在 main 分支， 切換到 dev--\u0026gt; git checout dev merge 將一個分支的更改合併到另一個分支\n\u0026lt;!--- 合併指定分支到當前分支 假設指定分支是 dev --\u0026gt; git merge dev push 將 commit 提交到遠端\n\u0026lt;!--- 假設遠端分支是 main --\u0026gt; git push origin main ","permalink":"https://bryan9411.github.io/posts/git-01/","summary":"Git 它是一個版本控制系統，可以幫助你追蹤程式碼變化、管理版本、合作開發，是團隊協作中不可或缺的工具之一。 以下是一些基本的 git 指令與使用情境 👇 init 當","title":"Git 基本指令"}]